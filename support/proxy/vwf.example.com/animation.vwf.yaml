# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

## @name animation.vwf
## @namespace

---

properties:

  ## xxx  TOOD: animationPlaying && animationEnabled && enabled

  animationEnabled:
    set: |
      this.paused = value;
    get: |
      return this.paused;

  ## xxx

  animationTime:

    set: |
      // console.warn( this.id, "time 1", this.animationStartTime, this.animationPauseTime, this.time, this.animationTime, this.animationPlaying );
      if ( this.animationRate >= 0 ) {
        value = Math.min( Math.max( 0, value ), this.animationDuration );
      } else {
        value = Math.min( Math.max( 0, value ), this.animationDuration ) - this.animationDuration;
      }
      var originalStartTime = this.animationStartTime;
      if ( this.animationStartTime ) {
        if ( ! this.animationPauseTime ) {
          this.animationStartTime = this.time - value / this.animationRate;
        } else {
          this.animationStartTime = this.animationPauseTime - value / this.animationRate;
        }
      } else {
        this.animationPauseTime = this.time;
        this.animationStartTime = this.time - value / this.animationRate;
      }
      if ( this.animationStartTime != originalStartTime ) {
        this.animationUpdate();
        this.animationTimeChanged();
      }
      // console.warn( this.id, "time 2", this.animationStartTime, this.animationPauseTime, this.time, this.animationTime, this.animationPlaying );
      //@ sourceURL=animation.vwf#time.set

    get: |
      if ( this.animationStartTime ) {
        if ( ! this.animationPauseTime ) {
          var value = ( this.time - this.animationStartTime ) * this.animationRate;
        } else {
          var value = ( this.animationPauseTime - this.animationStartTime ) * this.animationRate;
        }
      } else {
          var value = 0;
      }
      if ( this.animationRate >= 0 ) {
        return value;
      } else {
        return value + duration;
      }

  ## xxx

  animationDuration: 1

  ## xxx

  animationRate: 1  # TODO: set/get

  ## xxx

  animationLoop: false


  ## xxx

  animationPlaying:

    set: |
      // console.warn( this.id, "playing 1", this.animationStartTime, this.animationPauseTime, this.time, this.animationTime, this.animationPlaying );
      if ( this.animationStartTime ) {
        if ( ! this.animationPauseTime ) {
          if ( ! value ) {
            this.animationPauseTime = this.time;
          }
        } else {
          if ( value ) {
            this.animationStartTime +=
              this.time - this.animationPauseTime;
            this.animationPauseTime = null;
            this.animationTick();
          }
        }
      } else {
        if ( value ) {
          this.animationStartTime = this.time;
          this.animationTick();
          this.animationStarted();
        }
      }
      // console.warn( this.id, "playing 2", this.animationStartTime, this.animationPauseTime, this.time, this.animationTime, this.animationPlaying );
    get: |
      return !! this.animationStartTime &&
        ! this.animationPauseTime;

  ## xxx

  animationStartTime: null

  ## xxx

  animationPauseTime: null

methods:

  # play from beginning

  animationPlay: |
    this.animationTime = 0;
    this.animationPlaying = true;

  # stop at current

  animationPause: |
    this.animationPlaying = false;

  # play from current

  animationResume: |
    this.animationPlaying = true;

  # stop and reset

  animationStop: |
    this.animationPlaying = false;
    this.animationTime = 0;
    //@ sourceURL=animation.vwf#stop

  animationTick: |
    // console.warn( this.id, "tick 1", this.animationStartTime, this.animationPauseTime, this.time, this.animationTime, this.animationPlaying );
    if ( ! this.animationTicking ) {
      this.logger.info( "animation: scheduling tick" );
    }
    if ( this.animationTime >= this.animationDuration ) {
      var animationTime = this.animationTime;
      this.animationTime = this.animationDuration;
      if ( this.animationLoop ) {
        while ( animationTime >= this.animationDuration ) {
          animationTime -= this.animationDuration;
          this.animationLooped();
        }
        this.animationTime = animationTime;
      } else {
        this.animationStopped();
        this.animationStop();
      }
    }
    if ( this.animationPlaying ) {
      this.animationTicking = true;
      this.animationUpdate();
      this.animationTimeChanged();
      this.future( 0.04 ).animationTick();
    } else {
      this.animationTicking = false;
      this.logger.info( "animation: canceling tick" );
    }
    // console.warn( this.id, "tick 2", this.animationStartTime, this.animationPauseTime, this.time, this.animationTime, this.animationPlaying );
    //@ sourceURL=animation.vwf#tick

  animationUpdate: |
    // TODO

events:
  animationStarted:
  animationStopped:
  animationLooped:
  animationTimeChanged:
